{"version":3,"file":"frontend-dbe862fc.js","sources":["../../frontend/js/LIVEKIT_TOKEN.js","../../frontend/js/simplePeerSub.ts","../../frontend/js/msgHandler.ts","../../frontend/js/livekit.ts","../../frontend/js/main.js"],"sourcesContent":["window.LIVEKIT_TOKEN = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ2aWRlbyI6eyJyb29tTGlzdCI6dHJ1ZSwicm9vbUpvaW4iOmZhbHNlLCJjYW5QdWJsaXNoIjpmYWxzZSwiY2FuU3Vic2NyaWJlIjpmYWxzZSwiY2FuUHVibGlzaERhdGEiOmZhbHNlfSwiaWF0IjoxNjc4NzI4ODY1LCJuYmYiOjE2Nzg3Mjg4NjUsImV4cCI6MTExMzk1Mjg4NjUsImlzcyI6IkFQSWtvRTdtM1pxZDVkSiIsInN1YiI6Imx0IiwianRpIjoibHQifQ.6mVaD452mZMSgXKWG7QDkxR__2v76urjJnJ66TjJGjs\"\n","import { sendLivekitMessage } from \"./livekit\";\nimport { SimplePeerConnection } from \"../../js/simplepeer\"\nimport { handleFrontendMsgRcvd } from \"./msgHandler\";\n\n\nlet simplePeerSub: SimplePeerConnection | null = null;\nexport const initSimplePeerSubscriber = (): SimplePeerConnection => {\n    // if (simplePeerPub) simplePeerPub.stop()\n    simplePeerSub = new SimplePeerConnection(handleFrontendMsgRcvd, (newState: string) => console.log(\"SIMPLEPEER new conn state:\", newState), (signalData) => {\n        sendLivekitMessage(signalData)\n    })\n    simplePeerSub.start({\n        initiator: true,\n        trickle: false,\n    })\n    return simplePeerSub;\n}\n\nexport const sendSignalingDataToSimplePeerSubscriber = (signalData: Uint8Array) => {\n    if (simplePeerSub) simplePeerSub.handleSignalingMsg(signalData);\n}\n","import { receiveProxiedMsg } from \"./proxy\";\nimport { sendSignalingDataToSimplePeerSubscriber } from \"./simplePeerSub\"\n\nexport function handleFrontendMsgRcvd(msgBytes: ArrayBufferLike) {\n    let data = new Uint8Array(msgBytes)\n    if (!data || data.length === 0) return;\n    console.log(\"GOT DC DATA:\", data);\n    sendSignalingDataToSimplePeerSubscriber(data);\n    // receiveProxiedMsg(msgBytes);\n}\n","import {\n    Room,\n    RoomEvent,\n    RemoteParticipant,\n    RemoteTrackPublication,\n    RemoteTrack,\n    Participant,\n    VideoPresets,\n    DefaultReconnectPolicy,\n    RoomConnectOptions,\n    LivekitError,\n    LocalTrackPublication,\n    LocalParticipant,\n    Track,\n    ParticipantEvent,\n    TrackPublication,\n    DisconnectReason,\n    MediaDeviceFailure,\n    ConnectionQuality,\n    DataPacket_Kind\n} from 'livekit-client';\nimport { DECODE_TXT, ENCODE_TXT, LIVEKIT_CLOUD_ENDPOINT, LIVEKIT_FRONTEND_ROOM_CONNECTION_CONFIG, LIVEKIT_LOCAL_ENDPOINT, PROXY_PREFIX } from '../../js/consts';\nimport { appendLog, getWebsocketURL, waitfor } from '../../js/util';\nimport { handleFrontendMsgRcvd } from './msgHandler';\nimport { setSendProxyMessageCallback } from './proxy';\nimport { enableFrameProxy } from \"./frameProxy\";\n\nlet videoContainerElem;\n\ndeclare global {\n    interface Window {\n        LIVEKIT_TOKEN: string;\n    }\n}\n\nexport async function listLivekitRooms(hostUrl: string) {\n    return await fetch(hostUrl + '/twirp/livekit.RoomService/ListRooms', {\n        method: 'POST',\n        cache: 'no-cache',\n        mode: 'cors',\n        body: JSON.stringify({}),\n        headers: {\n            'Content-Type': 'application/json',\n            'Authorization': 'Bearer ' + window.LIVEKIT_TOKEN,\n        }\n    }).then(response => response.json()).then(response => {\n        const rooms = response.rooms;\n        if (!rooms || !Array.isArray(rooms)) throw new Error(`Error getting livekit room list from ${hostUrl} - ${JSON.stringify(response)}`)\n        return rooms.filter(room => room['num_participants'] > 0)\n    }).catch((e) => {\n        console.warn(`Error getting livekit room list from  - ${hostUrl}`, e)\n        return [];\n    });\n}\n\ntype msgQueueItem = { msgBytes: Uint8Array, onSendCallback: (msgBytes: Uint8Array) => void }\ntype MsgRecivedCallback = (msg: Uint8Array, roomId: string, hostUrl: string) => void;\ntype StateChangeCallback = (connState: string, roomId: string, hostUrl: string) => void;\n\nexport class LivekitClientConnection {\n    roomId: string;\n    hostUrl: string;\n    accessToken: string;\n    roomConn: Room;\n    videoElem: Element;\n\n    onMesssageRecived: MsgRecivedCallback;\n    onConnStateChange: StateChangeCallback;\n\n    constructor(hostUrl: string, onMesssageRecived: MsgRecivedCallback, onConnStateChange: StateChangeCallback) {\n        this.hostUrl = hostUrl;\n        this.onMesssageRecived = (msg: Uint8Array) => onMesssageRecived(msg, this.roomId, this.hostUrl);\n        this.onConnStateChange = (connState: string) => onConnStateChange(connState, this.roomId, this.hostUrl);\n\n        // creates a new room object with options\n        this.roomConn = new Room({\n            // specify how offten to retry connection when it fails.\n            reconnectPolicy: new DefaultReconnectPolicy(),\n            // automatically manage subscribed video quality\n            adaptiveStream: true,\n        });\n    }\n\n    async start(roomId: string, accessToken: string) {\n        console.log(`Starting conn with ${roomId} via ${this.hostUrl} token = ${accessToken}`)\n        const startTime = Date.now();\n        this.roomId = roomId;\n\n        // set up event listeners\n        this.roomConn\n            .on(RoomEvent.SignalConnected, async () => {\n                const signalConnectionTime = Date.now() - startTime;\n                appendLog(`signal connection established in ${signalConnectionTime}ms`);\n            })\n            .on(RoomEvent.Connected, async () => {\n                appendLog(`Connected to room: ${this.roomConn.name} via ${this.hostUrl}`)\n            })\n            .on(RoomEvent.Disconnected, (reason?: DisconnectReason) => {\n                if (!this.roomConn) return;\n                appendLog('disconnected from room', { reason }, this.roomConn.localParticipant);\n                this.roomConn.participants.forEach((p) => { });\n            })\n            .on(RoomEvent.Reconnecting, () => {\n                appendLog('Reconnecting to room')\n            })\n            .on(RoomEvent.Reconnected, async () => {\n                appendLog(\n                    'Successfully reconnected. server',\n                    await this.roomConn.engine.getConnectedServerAddress(),\n                );\n            })\n            .on(RoomEvent.ParticipantConnected, async (participant: Participant) => {\n                appendLog('participant', participant.identity, 'connected', participant.metadata);\n                participant\n                    .on(ParticipantEvent.TrackMuted, (pub: TrackPublication) => {\n                        appendLog('track was muted', pub.trackSid, participant.identity);\n                    })\n                    .on(ParticipantEvent.TrackUnmuted, (pub: TrackPublication) => {\n                        appendLog('track was unmuted', pub.trackSid, participant.identity);\n                    })\n                    .on(ParticipantEvent.IsSpeakingChanged, () => {\n                        appendLog('ParticipantEvent.IsSpeakingChanged', participant.isSpeaking);\n                    })\n                    .on(ParticipantEvent.ConnectionQualityChanged, () => {\n                        appendLog('ParticipantEvent.ConnectionQualityChanged', participant.connectionQuality);\n                    });\n            })\n            .on(RoomEvent.ParticipantDisconnected, (participant: RemoteParticipant) => {\n                appendLog('participant', participant.sid, 'disconnected');\n            })\n            .on(RoomEvent.MediaDevicesError, (e: Error) => {\n                const failure = MediaDeviceFailure.getFailure(e);\n                appendLog('media device failure', failure);\n            })\n            .on(RoomEvent.ConnectionQualityChanged, (quality: ConnectionQuality, participant?: Participant) => {\n                appendLog('connection quality changed', participant?.identity, quality);\n            })\n            .on(RoomEvent.TrackSubscribed, (\n                track: RemoteTrack,\n                publication: RemoteTrackPublication,\n                participant: RemoteParticipant,\n            ) => {\n                if (track.kind === Track.Kind.Video) {\n                    // attach it to a HTMLVideoElement or HTMLAudioElement\n                    this.videoElem = track.attach(document.getElementById(\"cloud_video\") as HTMLVideoElement);\n                    this.videoElem.setAttribute(\"host\", this.hostUrl)\n                    videoContainerElem = document.getElementById(\"video_container\");\n                } // else if (track.kind === Track.Kind.Audio) {}\n                console.log(track, this.hostUrl)\n            })\n            .on(RoomEvent.TrackUnsubscribed, (\n                track: RemoteTrack,\n                publication: RemoteTrackPublication,\n                participant: RemoteParticipant,\n            ) => {\n                // remove tracks from all attached elements\n                track.detach();\n            })\n            .on(RoomEvent.DataReceived, async (msg: Uint8Array, participant?: RemoteParticipant) => {\n                const person = participant ? participant.identity : \"SERVER\";\n                appendLog(`Got dataReceived from ${person} via ${this.hostUrl}|${this.roomId}`, DECODE_TXT(msg));\n                this.onMesssageRecived(msg, this.roomId, this.hostUrl)\n            })\n            .on(RoomEvent.LocalTrackUnpublished, (track: LocalTrackPublication, participant: LocalParticipant) => {\n                console.error(\"handleLocalTrackUnpublished: _THIS SHOULD NEVER BE HAPPENING_\", track, participant)\n            })\n            .on(RoomEvent.RoomMetadataChanged, (metadata) => {\n                appendLog('new metadata for room', metadata);\n            })\n            .on(RoomEvent.MediaDevicesChanged, () => {\n                appendLog('MediaDevicesChanged _THIS SHOULDN\\'T HAPPEN?_');\n            })\n            .on(RoomEvent.AudioPlaybackStatusChanged, () => {\n                appendLog('AudioPlaybackStatusChanged _THIS SHOULDN\\'T HAPPEN?_', this.roomConn.canPlaybackAudio);\n            })\n\n        await this.roomConn.connect(getWebsocketURL(this.hostUrl), accessToken, LIVEKIT_FRONTEND_ROOM_CONNECTION_CONFIG); // local: 'ws://localhost:7800',\n        console.info('connected to room', this.roomConn.name, this.roomConn);\n\n        return true;\n    }\n\n    sendMessage(msgBytes: Uint8Array, onSendCallback?: () => void, skipQueue = false) {\n        // const rov = this.roomConn.getParticipantByIdentity(this.roomId);\n        console.log(\"sendMessage() to rov \", msgBytes)\n        this.roomConn.localParticipant.publishData(msgBytes, DataPacket_Kind.RELIABLE)\n    }\n\n    close() {\n        console.info(\"Closing Livekit Connection: \", this.roomId, this.hostUrl);\n        if (this.roomConn) {\n            this.roomConn.disconnect(true);\n        }\n    }\n\n}\n\nconst cloudLivekitConnection = new LivekitClientConnection(LIVEKIT_CLOUD_ENDPOINT, (msg, roomId, hostUrl) => {\n    handleFrontendMsgRcvd(msg)\n}, (state, roomId, hostUrl) => {\n    console.log(\"Cloud Conn State Changed: \" + state, roomId, hostUrl)\n})\n\n// const localLivekitConnection = new LivekitClientConnection(PROXY_PREFIX + LIVEKIT_LOCAL_ENDPOINT, (msg, roomId, hostUrl) => {\n//     handleFrontendMsgRcvd(msg)\n// }, (state, roomId, hostUrl) => {\n//     console.log(\"Local Conn State Changed: \" + state, roomId, hostUrl)\n// })\n\nexport async function connectToRoom(roomName, accessToken) {\n    await cloudLivekitConnection.start(roomName, accessToken);\n}\n\nexport async function connectToRoomLocal(roomName, accessToken) {\n    if (!window.parent || window.parent === window.top) {\n\n        // FOR LOCAL OVER CLOUD PROXY\n        // setSendProxyMessageCallback((data) => {\n        //     console.log(\"send proxy message: \" + data.byteLength);\n        //     cloudLivekitConnection.sendMessage(new Uint8Array(data))\n        // })\n    } else {\n        // enableFrameProxy();\n        // await waitfor(100);\n        // await localLivekitConnection.start(roomName, accessToken);\n    }\n\n    // await waitfor(100);\n}\n\nexport async function sendTestMessage() {\n    // localLivekitConnection.sendMessage(ENCODE_TXT(\"HI FROM FRONTEND SHOULD BE LOCAL\"))\n    cloudLivekitConnection.sendMessage(ENCODE_TXT(\"HI FROM FRONTEND SHOULD BE CLOUD\"))\n}\n\n\nexport function sendLivekitMessage(data: Uint8Array) {\n    cloudLivekitConnection.sendMessage(data)\n}\n\n\n\n\n\n// await waitfor(1000);\n\n// let msg = JSON.stringify({\n//     url: 'http://wow.com',\n//     body: new Array(...ENCODE_TXT(\"BooO\")),\n//     type: proxyMessageTypes.socketMsg\n// })\n// console.log(\"smg\", msg)\n// this.roomConn.localParticipant.publishData(new Uint8Array(ENCODE_TXT(msg)), DataPacket_Kind.RELIABLE)\n","import { connectToRoom, connectToRoomLocal, listLivekitRooms, sendTestMessage } from \"./livekit\";\nimport { waitfor } from \"../../js/util\"\nimport { DECODE_TXT, ENCODE_TXT, LIVEKIT_CLOUD_ENDPOINT, LIVEKIT_LOCAL_ENDPOINT, PROXY_PREFIX } from \"../../js/consts\";\nimport { handleFrontendMsgRcvd } from \"./msgHandler\";\nimport { initSimplePeerSubscriber } from \"./simplePeerSub\";\n// import { setSendProxyMessageCallback } from \"./proxy\";\n\n// import { SignalRequest } from \"livekit-client/dist/src/proto/livekit_rtc\";\n\nconst urlParams = new URLSearchParams(location.search);\nconst rovChooserElem = document.getElementById(\"rov_chooser\")\nconst videContainerElem = document.getElementById(\"video_container\")\nconst openRooms = [];\n\nasync function start() {\n    console.log(\"Starting...\")\n\n    const sendTestButton = document.createElement(\"button\");\n    sendTestButton.innerText = \"Send test msg\";\n    sendTestButton.disabled = true;\n    sendTestButton.onclick = () => {\n        sendTestMessage();\n    }\n    document.body.appendChild(sendTestButton);\n\n    while (true) {\n        const cloudRooms = await listLivekitRooms(LIVEKIT_CLOUD_ENDPOINT)\n        // const localRooms = await listLivekitRooms(LIVEKIT_LOCAL_ENDPOINT)\n        // console.log(\"cloud rooms:\", cloudRooms, \"local rooms:\", localRooms)\n        const rooms = cloudRooms;\n        // const rooms = [{\n        //     name: \"ROV77\",\n        //     metadata: '{\"accessToken\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiUEVSU09OMTY3OTU4MzIyOTUyNCIsInZpZGVvIjp7InJvb20iOiJST1Y3NyIsInJvb21MaXN0Ijp0cnVlLCJyb29tSm9pbiI6dHJ1ZSwiY2FuUHVibGlzaCI6dHJ1ZSwiY2FuU3Vic2NyaWJlIjp0cnVlLCJjYW5QdWJsaXNoRGF0YSI6dHJ1ZX0sImlhdCI6MTY3OTU4MzIyOSwibmJmIjoxNjc5NTgzMjI5LCJleHAiOjE2Nzk2MDQ4MjksImlzcyI6IkFQSWtvRTdtM1pxZDVkSiIsInN1YiI6IlBFUlNPTjE2Nzk1ODMyMjk1MjQiLCJqdGkiOiJQRVJTT04xNjc5NTgzMjI5NTI0In0.2sm5PnnzjmaeV5EVrQvLR5kROF3w0_uVU-G5uwSUZ-0\"}'\n        // }]\n        if (rooms.length > 0) {\n            rovChooserElem.innerHTML = \"\";\n            rooms.forEach(room => {\n                if (!room.metadata) return;\n                const button = document.createElement(\"button\");\n                const { accessToken } = JSON.parse(room.metadata);\n                button.innerText = \"Connect to \" + room.name;\n                button.onclick = () => {\n                    connectToRoom(room.name, accessToken).then(() => {\n                        sendTestButton.disabled = false;\n                        button.innerText = \"Connect locally to \" + room.name;\n                        button.onclick = () => {\n                            // connectToRoomLocal(room.name, accessToken).then(() => { });\n                            initSimplePeerSubscriber()\n                        }\n                    });\n                }\n                rovChooserElem.appendChild(button);\n            });\n        } else {\n            rovChooserElem.innerHTML = \"Searching...\";\n        }\n        await waitfor(1000);\n        break;\n    }\n}\nstart()\n// registerServiceWorker();\n\n\n\n\n// wsHook.beforeSend = function (data, url, wsObject) {\n//     // DECODE_TXT(data)\n//     // DECODE_TXT(new Uint8Array(data))\n//     // let data2 = new Uint8Array(data);\n//     // let txt = new TextDecoder().decode(data)\n//     let resp = {};\n//     if (typeof data === 'string') {\n//         const json = JSON.parse(data);\n//         resp = SignalRequest.fromJSON(json);\n//     } else if (data instanceof ArrayBuffer || data instanceof Uint8Array) {\n//         resp = SignalRequest.decode(new Uint8Array(data));\n//     } else {\n//         log.error(`could not decode outgoing websocket message: ${typeof data}`);\n//     }\n//     console.log(\"Sending message to \" + url + \" : \", resp);\n//     return data\n// }\n\n// // Make sure your program calls `wsClient.onmessage` event handler somewhere.\n// wsHook.afterRecive = function (messageEvent, url, wsObject) {\n//     //  DECODE_TXT(new Uint8Array(messageEvent.data)));\n//     // console.log(\"Received message from \" + url + \" : \", DECODE_TXT(messageEvent.data));\n//     // https://github.com/livekit/client-sdk-js/blob/fa814646a6b345030019dace587508f8a10812d9/src/api/SignalClient.ts#L229\n//     // if (typeof ev.data === 'string') {\n//     //     const json = JSON.parse(ev.data);\n//     //     resp = SignalResponse.fromJSON(json);\n//     // } else if (ev.data instanceof ArrayBuffer) {\n//     //     resp = SignalResponse.decode(new Uint8Array(ev.data));\n//     // } else {\n//     //     log.error(`could not decode websocket message: ${typeof ev.data}`);\n//     //     return;\n//     // }\n//     return messageEvent;\n// }\n\n\n\n// new WebSocket().onmessage((ev) => { ev.})\n\n// // if you do not want to propagate the MessageEvent further down, just return null\n// wsHook.after = function(messageEvent, url, wsObject) {\n//  console.log(\"Received message from \" + url + \" : \" + messageEvent.data);\n//  // This example can ping-pong forever, so maybe use some conditions\n//  wsObject.send(\"Intercepted and sent again\")\n//  return null;\n// }\n"],"names":["simplePeerSub","initSimplePeerSubscriber","SimplePeerConnection","handleFrontendMsgRcvd","newState","signalData","sendLivekitMessage","sendSignalingDataToSimplePeerSubscriber","msgBytes","data","listLivekitRooms","hostUrl","response","rooms","room","LivekitClientConnection","onMesssageRecived","onConnStateChange","__publicField","msg","connState","Room","DefaultReconnectPolicy","roomId","accessToken","startTime","RoomEvent","signalConnectionTime","appendLog","reason","p","participant","ParticipantEvent","pub","e","failure","MediaDeviceFailure","quality","track","publication","Track","person","DECODE_TXT","metadata","getWebsocketURL","LIVEKIT_FRONTEND_ROOM_CONNECTION_CONFIG","onSendCallback","skipQueue","DataPacket_Kind","cloudLivekitConnection","LIVEKIT_CLOUD_ENDPOINT","state","connectToRoom","roomName","sendTestMessage","ENCODE_TXT","rovChooserElem","start","sendTestButton","button","waitfor"],"mappings":"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"}