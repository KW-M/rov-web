{"version":3,"file":"index-d7d62d7e.js","sources":["../../rov-backend/internal_webpages/js/websocketRelay.ts","../../rov-backend/internal_webpages/js/msgHandler.ts","../../rov-backend/internal_webpages/js/twitchStream.ts","../../rov-backend/internal_webpages/js/internalConnManager.ts","../../rov-backend/internal_webpages/js/main.ts"],"sourcesContent":["\n\n/*\n    Wrapper class for the WebSocket built-in javascript module. Acts as a proxy for communication\n    between the iROV internal website and its python code. At the time of writing this comment (5/22/2023)\n    the URL for the websocket server that the iROV python is expected to host is ws://localhost:8765/\n*/\nexport class WebSocketRelay {\n\n    socket: WebSocket\n    serverAddress: string\n    msgReceivedFn: (msg: Uint8Array) => void\n    isRunning: boolean\n    isConnected: boolean\n    connectionTimerId // type is \"a positive integer\"\n\n    /*\n        When instantiated, an arbitrary callback function is expected to handle incoming messages\n        from the iROV. The boolean flag isConnected is used to keep track of the connection status\n        and is set to false by default. isRunning is used to track whether or not the relay should actively\n        try to connect/reconnect (in the event of an error or the socket getting closed.) By default, this\n        is false and is set to true only when the user activates the relay using the start() method.\n    */\n    constructor() {\n        this.isConnected = false\n        this.isRunning = false\n        this.connectionTimerId = 0\n        this.serverAddress = \"\"\n    }\n\n    /*\n        This function MUST be invoked for the iROV to even start reaching out to connect.\n        After it is called, it will continue attempting to maintain connection unless stop()\n        is invoked.\n    */\n    start(serverAddress: string, msgReceivedFn: (msg: Uint8Array) => void) {\n        this.serverAddress = serverAddress\n        this.msgReceivedFn = msgReceivedFn;\n        this.isRunning = true\n        this.connect()\n    }\n\n    stop() {\n        this.isRunning = false\n        this.socket.close()\n    }\n\n    /*\n        Meant to be used internally. Connection and Reconnection both occur through instantiating a new\n        WebSocket and assigning callbacks. Arbitrary delays occur in the event of a di\n    */\n    connect() {\n        console.log(\"Attempting to connect to python websocket...\")\n        this.socket = new WebSocket(this.serverAddress);\n        this.socket.binaryType = \"blob\"\n        this.isConnected = true\n        this.socket.addEventListener('close', (event) => {\n            console.log('WebSocket connection closed with code: ', event.code);\n            this.isConnected = false\n            if (this.isRunning) this.queueConnect()\n        });\n\n        this.socket.addEventListener('error', (error) => {\n            console.error('WebSocket error:', error);\n            this.isConnected = false\n            if (this.isRunning) this.queueConnect()\n        });\n\n        this.socket.addEventListener(\"message\", (msgEvent: MessageEvent<Blob>) => {\n            msgEvent.data.arrayBuffer().then((arrayBuffer) => {\n                this.msgReceivedFn(new Uint8Array(arrayBuffer))\n            })\n        })\n\n    }\n\n    /*\n        Helper function that sets a delay for the connect() function to be called\n        asynchronously. Used for trying to reconnect if the server is unresponsive\n    */\n    queueConnect() {\n        // console.log(\"queuing connect(), clearing ID=\", this.connectionTimerId)\n        clearTimeout(this.connectionTimerId) // Unqueue any current connection events.\n        this.connectionTimerId = setTimeout(this.connect.bind(this), 2000); // Attempt to reconnect after a delay\n        // console.log(\"finished queuing connect(), new ID=\", this.connectionTimerId)\n    }\n\n    getIsConnected() {\n        return this.isConnected\n    }\n\n    /*\n        Sends an arbitrary byte sequence through the WebSocket\n    */\n    sendMessage(message: Uint8Array) {\n        this.socket.send(message)\n    }\n\n\n}\n\nexport const iRovWebSocketRelay = new WebSocketRelay()\n","import { rov_actions_proto } from \"../../../shared/js/protobufs/rovActionsProto\";\nimport { internalConnManager } from \"./internalConnManager\";\nimport { iRovWebSocketRelay } from \"./websocketRelay\";\n\n\nfunction handleInternalWebpageActions(senderId: string, msgProto: rov_actions_proto.RovAction) {\n    if (msgProto.SimplepeerSignal) {\n        internalConnManager.ingestSimplePeerSignallingMsg(senderId, msgProto.SimplepeerSignal.Message)\n        return true;\n    } else return false;\n}\n\n/*\n    Intended to handle messages coming FROM Livekit/The Internet\n    TODO We wish to send this data to the iROV python code\n*/\nexport function backendHandleWebrtcMsgRcvd(senderId: string, msgBytes: ArrayBufferLike) {\n    let data = new Uint8Array(msgBytes)\n    if (!data || data.length === 0) return;\n\n    // Decode the protobuf object from bytes\n    const msgProto = rov_actions_proto.RovAction.decode(data)\n    if (handleInternalWebpageActions(senderId, msgProto)) return;\n\n    // Stuff the protobuff object with metadata\n    msgProto.BackendMetadata = msgProto.BackendMetadata || new rov_actions_proto.ActionBackendMetadata()\n    msgProto.BackendMetadata.FromUserId = senderId\n    const newMessage = rov_actions_proto.RovAction.encode(msgProto).finish()\n\n    // Send the re-packaged up message bytes to the iROV python via webSocketRelay\n    if (iRovWebSocketRelay.isConnected) iRovWebSocketRelay.sendMessage(newMessage)\n}\n","import '../../../shared/js/nodeShimsBundle'\nimport * as livekitServerSDKTypes from 'livekit-server-sdk';\nconst EgressClient = globalThis.livekitServerSDK.EgressClient as typeof livekitServerSDKTypes.EgressClient\nconst StreamProtocol = globalThis.livekitServerSDK.StreamProtocol as typeof livekitServerSDKTypes.StreamProtocol\n\nclass TwitchStream {\n    private _twitchStreamKey: string = null;\n    private _egressClient: livekitServerSDKTypes.EgressClient = null;\n    private roomName: string = null;\n    private streamEgressID: string = null;\n\n    init(twitchStreamKey: string, roomName: string, apiKey: string, secretKey: string) {\n        this._twitchStreamKey = twitchStreamKey;\n        this.roomName = roomName;\n        this._egressClient = new EgressClient('https://rov-web.livekit.cloud', apiKey, secretKey);\n    }\n\n    async startStream() {\n        if (!this._twitchStreamKey) return console.warn(\"startStream() err: Twitch stream key not set!\");\n        const output = {\n            protocol: StreamProtocol.RTMP,\n            urls: ['rtmp://live.twitch.tv/app/' + this._twitchStreamKey]\n        };\n        var info = await this._egressClient.startRoomCompositeEgress(this.roomName, output);\n        this.streamEgressID = info.egressId;\n    }\n\n    async stopStream() {\n        if (!this.streamEgressID) return console.warn(\"stopStream() err: Twitch Stream not started!\");\n        const info = await this._egressClient.stopEgress(this.streamEgressID);\n    }\n\n}\n\nexport const twitchStream = new TwitchStream();\n","import { LivekitPublisherConnection } from \"../../../shared/js/livekit/livekitConn\"\nimport { LIVEKIT_CLOUD_ENDPOINT, LIVEKIT_LOCAL_ENDPOINT, LIVEKIT_BACKEND_ROOM_CONNECTION_CONFIG, DECODE_TXT, ENCODE_TXT, PROXY_PREFIX, LIVEKIT_BACKEND_ROOM_CONFIG, ConnectionStates } from '../../../shared/js/consts';\nimport { asyncExpBackoff, changesSubscribe, getWebsocketURL, waitfor } from '../../../shared/js/util';\nimport { getPublisherAccessToken } from '../../../shared/js/livekit/livekitTokens';\nimport { backendHandleWebrtcMsgRcvd } from './msgHandler'\nimport { createLivekitRoom, listLivekitRooms, newLivekitAdminSDKRoomServiceClient, refreshMetadata } from '../../../shared/js/livekit/adminActions';\nimport { SimplePeerConnection } from \"../../../shared/js/simplePeer\"\nimport type { LivekitSetupOptions } from \"../../../shared/js/livekit/adminActions\";\nimport { rov_actions_proto } from \"../../../shared/js/protobufs/rovActionsProto\";\nimport { twitchStream } from \"./twitchStream\";\n\n/** InternalConnectionManager\n * consolidates all the internet-facing connections of the internal webpage into one place\n * messages from any connection are passed to the msgHandler\n * outgoing messages to each user are sent through whichever connection to that user which was most recently active.\n */\nclass InternalConnectionManager {\n    private _cloudLivekitConnection: LivekitPublisherConnection = new LivekitPublisherConnection();\n    // private _localLivekitConnection: LivekitPublisherConnection = new LivekitPublisherConnection();\n    private _simplePeerConnections: { [userId: string]: SimplePeerConnection } = {};\n    private _cameraMediaStream: MediaStream = null;\n\n    constructor() {\n        // Initlize (but don't start) the cloud livekit connection:\n        this._cloudLivekitConnection.init({\n            hostUrl: LIVEKIT_CLOUD_ENDPOINT,\n            publishVideo: true,\n            reconnectAttempts: 300,\n            roomConnectionConfig: LIVEKIT_BACKEND_ROOM_CONNECTION_CONFIG,\n            roomConfig: LIVEKIT_BACKEND_ROOM_CONFIG\n        })\n        changesSubscribe(this._cloudLivekitConnection.latestRecivedDataMessage, (msgObj) => {\n            if (!msgObj) return;\n            const { senderId, msg } = msgObj;\n            backendHandleWebrtcMsgRcvd(senderId, msg)\n        })\n        changesSubscribe(this._cloudLivekitConnection.connectionState, (state) => {\n            console.log(\"Cloud Conn State Changed: \" + state)\n            if (state == ConnectionStates.connected) {\n                twitchStream.startStream()\n            }\n        })\n        changesSubscribe(this._cloudLivekitConnection.participantConnectionEvents, (evt) => {\n            console.log(\"Cloud Conn Participant Event: \", evt)\n        })\n\n        // Initlize (but don't start) the local livekit connection:\n        // this._localLivekitConnection.init({\n        //     hostUrl: LIVEKIT_LOCAL_ENDPOINT,\n        //     publishVideo: true,\n        //     reconnectAttempts: 300,\n        //     roomConnectionConfig: LIVEKIT_BACKEND_ROOM_CONNECTION_CONFIG,\n        //     roomConfig: LIVEKIT_BACKEND_ROOM_CONFIG\n        // })\n\n        // changesSubscribe(this._localLivekitConnection.latestRecivedDataMessage, (msgObj) => {\n        //     if (!msgObj) return;\n        //     const { senderId, msg } = msgObj;\n        //     backendHandleWebrtcMsgRcvd(senderId, msg)\n        // })\n        // changesSubscribe(this._localLivekitConnection.connectionState, (state) => {\n        //     console.log(\"Local Conn State Changed: \" + state)\n        // })\n        // changesSubscribe(this._localLivekitConnection.participantConnectionEvents, (evt) => {\n        //     console.log(\"Local Conn Participant Event: \", evt)\n        // })\n    }\n\n    private async cameraReady(stream: MediaStream) {\n        this._cameraMediaStream = stream;\n        if (this._cloudLivekitConnection && this._cloudLivekitConnection.connectionState.get() == ConnectionStates.connected && this._cameraMediaStream) await this._cloudLivekitConnection._roomConn.localParticipant.setCameraEnabled(true)\n        // if (this._localLivekitConnection && this._localLivekitConnection.connectionState.get() == ConnectionStates.connected && this._cameraMediaStream) await this._localLivekitConnection._roomConn.localParticipant.setCameraEnabled(true)\n    }\n\n    public async start(livekitSetup: LivekitSetupOptions) {\n        if (livekitSetup.EnableLivekitCloud) await asyncExpBackoff(this._cloudLivekitConnection.startRoom, this._cloudLivekitConnection, 10, 1000, 1.3)(livekitSetup.RovName, livekitSetup.LivekitAPIKey, livekitSetup.LivekitSecretKey).catch((e) => { console.error(e); window.location.reload() });\n        // if (livekitSetup.EnableLivekitLocal) await asyncExpBackoff(this._localLivekitConnection.startRoom, this._localLivekitConnection, 10, 1000, 1.3)(livekitSetup.RovName, livekitSetup.LivekitAPIKey, livekitSetup.LivekitSecretKey).catch((e) => { console.error(e); window.location.reload() });\n        asyncExpBackoff(navigator.mediaDevices.getUserMedia, navigator.mediaDevices, 10, 1000, 1.3)({ video: true, audio: false }).then(this.cameraReady.bind(this)).catch((e) => { console.error(e); window.location.reload() });\n        console.info(\"Connection Manager Started\")\n    }\n\n    public async startSimplePeerConnection(userId: string, firstSignallingMessage?: string) {\n        if (this._simplePeerConnections[userId]) {\n            this._simplePeerConnections[userId].stop();\n            delete this._simplePeerConnections[userId];\n        }\n        const spConn = new SimplePeerConnection();\n        changesSubscribe(spConn.latestRecivedDataMessage, (msg) => {\n            backendHandleWebrtcMsgRcvd(userId, msg)\n        })\n        changesSubscribe(spConn.outgoingSignalingMessages, (msg) => {\n            this.sendMessage({ SimplepeerSignal: { Message: msg } }, true, [userId])\n        })\n        await spConn.start({\n            initiator: false,\n            trickle: false,\n            streams: [this._cameraMediaStream]\n        })\n\n        this._simplePeerConnections[userId] = spConn;\n        if (firstSignallingMessage) spConn.ingestSignalingMsg(firstSignallingMessage);\n    }\n\n    public async ingestSimplePeerSignallingMsg(userId: string, signallingMsg: string) {\n        const spConn = this._simplePeerConnections[userId]\n        if (spConn) {\n            if ([ConnectionStates.failed, ConnectionStates.disconnectedOk, ConnectionStates.init].includes(spConn.connectionState.get())) {\n                await this.startSimplePeerConnection(userId, signallingMsg);\n            } else spConn.ingestSignalingMsg(signallingMsg);\n        } else await this.startSimplePeerConnection(userId, signallingMsg);\n    }\n\n    public async _sendMessageViaLivekit(msg: Uint8Array, reliable: boolean, toUserIds: string[]) {\n        await this._cloudLivekitConnection.sendMessage(msg, reliable, toUserIds);\n        // await this._localLivekitConnection.sendMessage(msg, reliable, toUserIds);\n    }\n\n    public async sendMessage(msg: rov_actions_proto.IRovResponse, reliable: boolean, toUserIds: string[]) {\n        console.log(\"Sending WEBRTC Message to: [\" + toUserIds.join(\", \") + \"] reliable: \" + reliable, msg)\n        const msgBytes = rov_actions_proto.RovResponse.encode(msg).finish();\n        // let sentToParticpants = [];\n        // if (!reliable) {\n        //     for (const userId of toUserIds) {\n        //         const spConn = this._simplePeerConnections[userId]\n        //         if (spConn && spConn.connectionState.get() == ConnectionStates.connected) {\n        //             await this._simplePeerConnections[userId].sendMessage(msgBytes);\n        //             sentToParticpants.push(userId);\n        //         }\n        //     }\n        //     if (sentToParticpants.length == toUserIds.length) return;\n        // }\n        const notSentPeers = toUserIds; //toUserIds.filter((userId) => !sentToParticpants.includes(userId));\n        await this._cloudLivekitConnection.sendMessage(msgBytes, reliable, notSentPeers);\n        // await this._localLivekitConnection.sendMessage(msgBytes, reliable, notSentPeers);\n    }\n\n}\n\n\nexport const internalConnManager = new InternalConnectionManager();\n","import { internalConnManager } from \"./internalConnManager\"\nimport { iRovWebSocketRelay } from \"./websocketRelay\";\nimport { rov_actions_proto } from \"../../../shared/js/protobufs/rovActionsProto\";\nimport type { LivekitSetupOptions } from \"../../../shared/js/livekit/adminActions\";\nimport { twitchStream } from \"./twitchStream\";\nimport { SECONDS_IN_DAY } from \"../../../shared/js/consts\";\n\n// DISABLE VITE HOT MOUDLE RELOADING:\nif (import.meta.hot)\n    import.meta.hot.accept(() => import.meta.hot.invalidate())\n\n// Get Setup Options from URL Query Params\nconst urlParams = new URLSearchParams(location.search);\nconst livekitConfig: LivekitSetupOptions = {\n    RovName: urlParams.get(\"RovName\"),\n    RovControlPassword: urlParams.get(\"RovControlPassword\"),\n    LivekitAPIKey: urlParams.get(\"LivekitApiKey\"),\n    LivekitSecretKey: urlParams.get(\"LivekitSecretKey\"),\n    TwitchStreamKey: urlParams.get(\"TwitchStreamKey\") || \"None\", // Twitch Stream Key (For Streaming, duh)\n    EnableLivekitLocal: (urlParams.get(\"ForceLocal\") || \"false\").toLowerCase() === 'true',\n    EnableLivekitCloud: (urlParams.get(\"EnableCloud\") || \"true\").toLowerCase() === 'true',\n    PythonWebsocketPort: parseInt(urlParams.get(\"PythonWebsocketPort\")) || 0,\n    AuthTokenTimeout: parseInt(urlParams.get(\"AuthTokenTimeout\")) || SECONDS_IN_DAY,\n}\nfor (const key in livekitConfig) if (livekitConfig[key] == undefined) throw new Error(\"Missing required url query parameter: \" + key);\n\n// Start Livekit\ninternalConnManager.start(livekitConfig)\n\n// Initialize Twitch Stream\nif (livekitConfig.TwitchStreamKey !== \"None\") {\n    twitchStream.init(livekitConfig.TwitchStreamKey, livekitConfig.RovName, livekitConfig.LivekitAPIKey, livekitConfig.LivekitSecretKey)\n    window.addEventListener(\"beforeunload\", () => twitchStream.stopStream()) // Stop Twitch Stream when page is closed\n}\n\n// Start Backend/Python Websocket Communication\nif (livekitConfig.PythonWebsocketPort != 0) iRovWebSocketRelay.start(\"ws://localhost:\" + livekitConfig.PythonWebsocketPort, (msgBytes: Uint8Array) => {\n    /*Callback to handle messages being received from the iROV python*/\n\n\n    // Decode protobuf object from bytes\n    if (msgBytes.length === 0) return;\n    const msgProto = rov_actions_proto.RovResponse.decode(msgBytes)\n\n    // Extract metadata from protobuf object\n    if (!msgProto.BackendMetadata) return console.error(\"No BackendMetadata in message from iROV\", msgProto.toJSON(), msgBytes);\n    const targetUserIds = msgProto.BackendMetadata.TargetUserIds\n    const transportMethod = msgProto.BackendMetadata.TransportMethod\n    const isReliable = transportMethod == rov_actions_proto.DataTransportMethod.LivekitReliable\n\n    // Send message on using livekit:\n    internalConnManager.sendMessage(msgProto, isReliable, targetUserIds)\n});\n\n\n\n\n// console.log(getFrontendAccessToken(urlParams.get(\"LivekitApiKey\"), urlParams.get(\"LivekitSecretKey\"), \"PERSON\" + Date.now().toString()))\n\n\n\n// setSendProxyMessageCallback((data) => {\n//     console.log(\"Sending Msg Through proxy. JK! \", DECODE_TXT(data));\n// })\n// let msg = JSON.stringify({\n//     url: 'http://wow.com',\n//     body: new Array(...ENCODE_TXT(\"ALL\")),\n//     type: proxyMessageTypes.socketMsg\n// })\n// console.log(\"smg\", msg)\n// // await waitfor(5000);\n\n// msg = JSON.stringify({\n//     url: 'http://wow.com',\n//     body: new Array(...ENCODE_TXT(\"BO\")),\n//     type: proxyMessageTypes.socketMsg\n// })\n// console.log(\"smg\", msg)\n"],"names":["LIVEKIT_CLOUD_ENDPOINT","LIVEKIT_BACKEND_ROOM_CONNECTION_CONFIG","LIVEKIT_BACKEND_ROOM_CONFIG","ConnectionStates","SECONDS_IN_DAY","rov_actions_proto","LivekitPublisherConnection","changesSubscribe","asyncExpBackoff","SimplePeerConnection","WebSocketRelay","__publicField","serverAddress","msgReceivedFn","event","error","msgEvent","arrayBuffer","message","iRovWebSocketRelay","handleInternalWebpageActions","senderId","msgProto","internalConnManager","backendHandleWebrtcMsgRcvd","msgBytes","data","newMessage","EgressClient","StreamProtocol","TwitchStream","twitchStreamKey","roomName","apiKey","secretKey","output","info","twitchStream","InternalConnectionManager","msgObj","msg","state","evt","stream","livekitSetup","e","userId","firstSignallingMessage","spConn","signallingMsg","reliable","toUserIds","notSentPeers","urlParams","livekitConfig","key","targetUserIds","isReliable"],"mappings":"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"}