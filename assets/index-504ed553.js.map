{"version":3,"file":"index-504ed553.js","sources":["../../rov-backend/internal_webpages/js/websocketRelay.ts","../../rov-backend/internal_webpages/js/msgHandler.ts","../../rov-backend/internal_webpages/js/connectionManager.ts","../../rov-backend/internal_webpages/js/main.ts"],"sourcesContent":["\n\n/*\n    Wrapper class for the WebSocket built-in javascript module. Acts as a proxy for communication\n    between the iROV internal website and its python code. At the time of writing this comment (5/22/2023)\n    the URL for the websocket server that the iROV python is expected to host is ws://localhost:8765/\n*/\nexport class WebSocketRelay {\n    \n    socket: WebSocket\n    msgReceivedFn: (msgEvent: MessageEvent<Uint8Array>) => void \n    isRunning: boolean\n    isConnected: boolean\n    connectionTimerId // type is \"a positive integer\"\n    \n    /*\n        When instantiated, an arbitrary callback function is expected to handle incoming messages\n        from the iROV. The boolean flag isConnected is used to keep track of the connection status\n        and is set to false by default. isRunning is used to track whether or not the relay should actively\n        try to connect/reconnect (in the event of an error or the socket getting closed.) By default, this\n        is false and is set to true only when the user activates the relay using the start() method.\n    */\n    constructor() {\n        this.isConnected = false\n        this.isRunning = false\n        this.connectionTimerId = 0\n    }\n\n    /*\n        This function MUST be invoked for the iROV to even start reaching out to connect.\n        After it is called, it will continue attempting to maintain connection unless stop()\n        is invoked.\n    */\n    start(msgReceivedFn: (msgEvent: MessageEvent<Uint8Array>) => void) {\n        this.msgReceivedFn = msgReceivedFn;\n        this.isRunning = true\n        this.connect()\n    }\n\n    stop() {\n        this.isRunning = false\n        this.socket.close()\n    }\n\n    /*\n        Meant to be used internally. Connection and Reconnection both occur through instantiating a new\n        WebSocket and assigning callbacks. Arbitrary delays occur in the event of a di\n    */\n    connect() {\n        console.log(\"Attempting to connect to python websocket...\")\n        this.socket = new WebSocket(\"ws://localhost:8765/\");\n        this.isConnected = true\n        this.socket.addEventListener('close', (event) => {\n          console.log('WebSocket connection closed with code: ', event.code);\n          this.isConnected = false\n          if(this.isRunning) this.queueConnect()\n        });\n      \n        this.socket.addEventListener('error', (error) => {\n          console.error('WebSocket error:', error);\n          this.isConnected = false\n          if(this.isRunning) this.queueConnect()\n        });\n\n        this.socket.addEventListener(\"message\", this.msgReceivedFn)\n      \n    }\n\n    /*\n        Helper function that sets a delay for the connect() function to be called\n        asynchronously. Used for trying to reconnect if the server is unresponsive\n    */\n    queueConnect() {\n        // console.log(\"queuing connect(), clearing ID=\", this.connectionTimerId)\n        clearTimeout(this.connectionTimerId) // Unqueue any current connection events.\n        this.connectionTimerId = setTimeout(this.connect.bind(this), 2000); // Attempt to reconnect after a delay\n        // console.log(\"finished queuing connect(), new ID=\", this.connectionTimerId)\n    }\n\n    getIsConnected() {\n        return this.isConnected\n    }\n\n    /*\n        Sends an arbitrary byte sequence through the WebSocket\n    */\n    sendMessage(message: Uint8Array) {\n        this.socket.send(message)\n    }\n\n\n}\n\nexport const iRovWebSocketRelay = new WebSocketRelay()","import { rov_actions_proto } from \"../../../shared/js/protobufs/rovActionsProto\";\nimport { receiveProxiedMsg } from \"../../../shared/js/proxyReciever\";\nimport { connectionManager } from \"./connectionManager\";\nimport { iRovWebSocketRelay } from \"./websocketRelay\";\n\n\nfunction handleInternalWebpageActions(senderId: string, msgProto: rov_actions_proto.RovAction) {\n    if (msgProto.SimplepeerSignal) {\n        connectionManager.ingestSimplePeerSignallingMsg(senderId, msgProto.SimplepeerSignal.Message)\n    }\n}\n\n/*\n    Intended to handle messages coming FROM Livekit/The Internet\n    TODO We wish to send this data to the iROV python code\n*/\nexport function backendHandleWebrtcMsgRcvd(senderId: string, msgBytes: ArrayBufferLike) {\n    let data = new Uint8Array(msgBytes)\n    if (!data || data.length === 0) return;\n    console.log(\"GOT DC DATA:\", data);\n\n    // Do some protobuf here to properly package the data up for iROV (stuff in the Sender Id)\n    const msgProto = rov_actions_proto.RovAction.decode(data)\n    msgProto.BackendMetadata = msgProto.BackendMetadata || new rov_actions_proto.ActionBackendMetadata()\n    msgProto.BackendMetadata.FromUserID = senderId\n    handleInternalWebpageActions(senderId, msgProto)\n    const newMessage = rov_actions_proto.RovAction.encode(msgProto).finish()\n\n    // Send the packaged up message to the iROV via webSocketRelay\n    if (iRovWebSocketRelay.isConnected) iRovWebSocketRelay.sendMessage(newMessage)\n\n    // sendSignalingDataToSimplePeerPublisher(data);\n    // receiveProxiedMsg(msgBytes);\n}\n","import { LivekitPublisherConnection } from \"../../../shared/js/livekit/livekitConn\"\nimport { LIVEKIT_CLOUD_ENDPOINT, LIVEKIT_LOCAL_ENDPOINT, LIVEKIT_BACKEND_ROOM_CONNECTION_CONFIG, DECODE_TXT, ENCODE_TXT, PROXY_PREFIX, LIVEKIT_BACKEND_ROOM_CONFIG } from '../../../shared/js/consts';\nimport { asyncExpBackoff, changesSubscribe, getWebsocketURL, waitfor } from '../../../shared/js/util';\nimport { getPublisherAccessToken } from '../../../shared/js/livekit/livekitTokens';\nimport { backendHandleWebrtcMsgRcvd } from './msgHandler'\nimport { createLivekitRoom, listLivekitRooms, newLivekitAdminSDKRoomServiceClient, refreshMetadata } from '../../../shared/js/livekit/adminActions';\nimport { SimplePeerConnection } from \"../../../shared/js/simplePeer\"\nimport type { LivekitSetupOptions } from \"../../../shared/js/livekit/adminActions\";\nimport { rov_actions_proto } from \"../../../shared/js/protobufs/rovActionsProto\";\n\n/** ConnectionManager\n * consolodate all the connections into one place\n * messages from any connection are passed to the msgHandler\n * outgoing messages to each user are sent through whichever connection to that user which was most recently active.\n */\nclass ConnectionManager {\n    private _cloudLivekitConnection: LivekitPublisherConnection = new LivekitPublisherConnection();\n    private _localLivekitConnection: LivekitPublisherConnection = new LivekitPublisherConnection();\n    private _simplePeerConnections: { [userId: string]: SimplePeerConnection } = {};\n    private _cameraMediaStream: MediaStream = null;\n\n    constructor() {\n        // Initlize (but don't start) the cloud livekit connection:\n        this._cloudLivekitConnection.init({\n            hostUrl: LIVEKIT_CLOUD_ENDPOINT,\n            publishVideo: true,\n            reconnectAttempts: 300,\n            roomConnectionConfig: LIVEKIT_BACKEND_ROOM_CONNECTION_CONFIG,\n            roomConfig: LIVEKIT_BACKEND_ROOM_CONFIG\n        })\n        changesSubscribe(this._cloudLivekitConnection.latestRecivedDataMessage, (msgObj) => {\n            if (!msgObj) return;\n            const { senderId, msg } = msgObj;\n            backendHandleWebrtcMsgRcvd(senderId, msg)\n        })\n        changesSubscribe(this._cloudLivekitConnection.connectionState, (state) => {\n            console.log(\"Cloud Conn State Changed: \" + state)\n        })\n\n        // Initlize (but don't start) the local livekit connection:\n        this._localLivekitConnection.init({\n            hostUrl: LIVEKIT_LOCAL_ENDPOINT,\n            publishVideo: true,\n            reconnectAttempts: 300,\n            roomConnectionConfig: LIVEKIT_BACKEND_ROOM_CONNECTION_CONFIG,\n            roomConfig: LIVEKIT_BACKEND_ROOM_CONFIG\n        })\n\n        changesSubscribe(this._localLivekitConnection.latestRecivedDataMessage, (msgObj) => {\n            if (!msgObj) return;\n            const { senderId, msg } = msgObj;\n            backendHandleWebrtcMsgRcvd(senderId, msg)\n        })\n        changesSubscribe(this._localLivekitConnection.connectionState, (state) => {\n            console.log(\"Local Conn State Changed: \" + state)\n        })\n    }\n\n    public async start(livekitSetup: LivekitSetupOptions) {\n        if (livekitSetup.EnableLivekitCloud) await asyncExpBackoff(this._setupLivekitRoom, this)(LIVEKIT_CLOUD_ENDPOINT, livekitSetup, this._cloudLivekitConnection)\n        if (livekitSetup.EnableLivekitLocal) await asyncExpBackoff(this._setupLivekitRoom, this)(LIVEKIT_LOCAL_ENDPOINT, livekitSetup, this._localLivekitConnection)\n        this._cameraMediaStream = await asyncExpBackoff(navigator.mediaDevices.getUserMedia, navigator.mediaDevices)({ video: true, audio: false });\n        console.log(\"ConnectionManager Started\")\n    }\n\n    public async startSimplePeerConnection(userId: string, firstSignallingMessage?: string) {\n        if (this._simplePeerConnections[userId]) {\n            this._simplePeerConnections[userId].stop();\n            delete this._simplePeerConnections[userId];\n        }\n        const spConn = new SimplePeerConnection();\n        changesSubscribe(spConn.latestRecivedDataMessage, (msg) => {\n            backendHandleWebrtcMsgRcvd(userId, msg)\n        })\n        changesSubscribe(spConn.outgoingSignalingMessages, (msg) => {\n            this.sendMessage({ SimplepeerSignal: { Message: msg } }, true, [userId])\n        })\n        await spConn.start({\n            initiator: false,\n            trickle: false,\n            streams: [this._cameraMediaStream]\n        })\n\n        this._simplePeerConnections[userId] = spConn;\n        if (firstSignallingMessage) spConn.ingestSignalingMsg(firstSignallingMessage);\n    }\n\n    public async ingestSimplePeerSignallingMsg(userId: string, signallingMsg: string) {\n        const spConn = this._simplePeerConnections[userId]\n        if (spConn) spConn.ingestSignalingMsg(signallingMsg);\n        else await this.startSimplePeerConnection(userId, signallingMsg);\n    }\n\n    public async _sendMessageViaLivekit(msg: Uint8Array, reliable: boolean, toUserIds: string[]) {\n        await this._cloudLivekitConnection.sendMessage(msg, reliable, toUserIds);\n        await this._localLivekitConnection.sendMessage(msg, reliable, toUserIds);\n    }\n\n    public async sendMessage(msg: rov_actions_proto.IRovResponse, reliable: boolean, toUserIds: string[]) {\n        const msgBytes = rov_actions_proto.RovResponse.encode(msg).finish();\n        await this._cloudLivekitConnection.sendMessage(msgBytes, reliable, toUserIds);\n        await this._localLivekitConnection.sendMessage(msgBytes, reliable, toUserIds);\n        for (const userId of toUserIds) {\n            if (this._simplePeerConnections[userId]) {\n                await this._simplePeerConnections[userId].sendMessage(msgBytes);\n            }\n        }\n    }\n\n    private async _setupLivekitRoom(HostName: string, livekitSetup: LivekitSetupOptions, livekitConnection: LivekitPublisherConnection) {\n        const cloudToken = getPublisherAccessToken(livekitSetup.CloudAPIKey, livekitSetup.CloudSecretKey, livekitSetup.RovRoomName);\n        const livekitAdminSDK = newLivekitAdminSDKRoomServiceClient(HostName, livekitSetup.CloudAPIKey, livekitSetup.CloudSecretKey)\n        await createLivekitRoom(livekitAdminSDK, livekitSetup.RovRoomName);\n        await refreshMetadata(livekitAdminSDK, livekitSetup);\n        await livekitConnection.start(livekitSetup.RovRoomName, cloudToken);\n        // let cloudRoomList = await listLivekitRooms(livekitAdminSDK);\n    }\n}\n\n\nexport const connectionManager = new ConnectionManager();\n","import { connectionManager } from \"./connectionManager\"\nimport { iRovWebSocketRelay } from \"./websocketRelay\";\nimport { rov_actions_proto } from \"../../../shared/js/protobufs/rovActionsProto\";\nimport type { LivekitSetupOptions } from \"../../../shared/js/livekit/adminActions\";\n\n\nconst urlParams = new URLSearchParams(location.search);\nconst livekitConfig: LivekitSetupOptions = {\n    RovRoomName: urlParams.get(\"RovRoomName\"),\n    CloudAPIKey: urlParams.get(\"CloudAPIKey\"),\n    CloudSecretKey: urlParams.get(\"CloudSecretKey\"),\n    LocalAPIKey: urlParams.get(\"LocalAPIKey\") || \"N/A\",\n    LocalSecretKey: urlParams.get(\"LocalSecretKey\") || \"N/A\",\n    EnableLivekitLocal: (urlParams.get(\"ForceLocal\") || \"false\").toLowerCase() === 'true',\n    EnableLivekitCloud: (urlParams.get(\"EnableCloud\") || \"true\").toLowerCase() === 'true',\n}\nfor (const key in livekitConfig) if (livekitConfig[key] == undefined) throw new Error(\"Missing some required livekit setup url query params.\");\nconnectionManager.start(livekitConfig)\niRovWebSocketRelay.start(function (messageEvent: MessageEvent<Uint8Array>) {\n    // Callback to handle messages being received from the iROV python\n\n    // Unpackage needed metadata from the protobuf object\n    const msgProto = rov_actions_proto.RovResponse.decode(messageEvent.data)\n    const targetUserIds = msgProto.BackendMetadata.TargetUserIDs\n    const transportMethod = msgProto.BackendMetadata.TransportMethod\n    const isReliable = transportMethod == rov_actions_proto.DataTransportMethod.LivekitReliable\n\n    // send this stuff to livekit\n    connectionManager.sendMessage(msgProto, isReliable, targetUserIds)\n});\n\n\n\n\n// console.log(getFrontendAccessToken(urlParams.get(\"CloudAPIKey\"), urlParams.get(\"CloudSecretKey\"), \"PERSON\" + Date.now().toString()))\n\n\n\n// setSendProxyMessageCallback((data) => {\n//     console.log(\"Sending Msg Through proxy. JK! \", DECODE_TXT(data));\n// })\n// let msg = JSON.stringify({\n//     url: 'http://wow.com',\n//     body: new Array(...ENCODE_TXT(\"ALL\")),\n//     type: proxyMessageTypes.socketMsg\n// })\n// console.log(\"smg\", msg)\n// // await waitfor(5000);\n\n// msg = JSON.stringify({\n//     url: 'http://wow.com',\n//     body: new Array(...ENCODE_TXT(\"BO\")),\n//     type: proxyMessageTypes.socketMsg\n// })\n// console.log(\"smg\", msg)\n"],"names":["LIVEKIT_CLOUD_ENDPOINT","LIVEKIT_BACKEND_ROOM_CONNECTION_CONFIG","LIVEKIT_BACKEND_ROOM_CONFIG","LIVEKIT_LOCAL_ENDPOINT","LivekitPublisherConnection","asyncExpBackoff","SimplePeerConnection","getPublisherAccessToken","newLivekitAdminSDKRoomServiceClient","createLivekitRoom","refreshMetadata","WebSocketRelay","__publicField","msgReceivedFn","event","error","message","iRovWebSocketRelay","handleInternalWebpageActions","senderId","msgProto","connectionManager","backendHandleWebrtcMsgRcvd","msgBytes","data","rov_actions_proto","newMessage","ConnectionManager","changesSubscribe","msgObj","msg","state","livekitSetup","userId","firstSignallingMessage","spConn","signallingMsg","reliable","toUserIds","HostName","livekitConnection","cloudToken","livekitAdminSDK","urlParams","livekitConfig","key","messageEvent","targetUserIds","isReliable"],"mappings":"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"}