{"version":3,"file":"YawRollViz.0bcd70ef.js","sources":["../../../../../../src/components/CompassDial.svelte","../../../../../../src/assets/shaders/AHRS_Sphere.glsl?raw","../../../../../../src/components/YawRollViz.svelte"],"sourcesContent":["<script lang=\"ts\">\n  import { rovHeading } from \"../js/sensors\";\n</script>\n\n<!-- <script>\n  let anim = () => {\n    angle = (angle + 1) % 360;\n    requestAnimationFrame(anim);\n  };\n  requestAnimationFrame(anim);\n</script> -->\n\n<div class={\"compass left-1/2 -translate-x-1/2 overflow-hidden bg-surface-900 rounded-full box-content border-slate-700 border-2 \" + $$props.class || \"\"} style=\"height:34px; min-width: 200px;\">\n  <div class=\"line\" />\n  <div class=\"bg\" id=\"compassDiscImg\" style:transform={`translateX(${$rovHeading}px)`} />\n</div>\n\n<style>\n  /* ********* Compass Display ********* */\n\n  .compass {\n    /* position: relative; */\n    max-width: 280px;\n  }\n\n  .compass::before {\n    position: absolute;\n    content: \" \";\n    top: 0;\n    z-index: 1;\n    left: 0;\n    width: 88px;\n    max-width: 40%;\n    height: 100%;\n    /* background: linear-gradient(to right, rgb(var(--color-surface-900) / 1), rgb(var(--color-surface-900) / 0)); */\n    background: linear-gradient(to right, rgb(0 0 0 / 1), rgb(0 0 0 / 0));\n  }\n\n  .compass::after {\n    position: absolute;\n    content: \" \";\n    top: 0;\n    right: 0;\n    z-index: 1;\n    width: 88px;\n    max-width: 40%;\n    height: 100%;\n    /* background: linear-gradient(to left, rgb(var(--color-surface-900) / 1), rgb(var(--color-surface-900) / 0)); */\n    background: linear-gradient(to left, rgb(0 0 0 / 1), rgb(0 0 0 / 0));\n  }\n\n  .compass .bg {\n    position: absolute;\n    z-index: 0;\n\n    width: 720%;\n    left: -310%;\n    height: 100%;\n\n    transform: translateX(0px);\n\n    background: url(\"../assets/ui-elements/COMPASS-v4.png\");\n    background-repeat: repeat-x;\n    background-position: center center;\n    background-size: 360px 34px;\n    /* background-size: 423.57px 40px; */\n  }\n\n  .compass .line {\n    position: absolute;\n    z-index: 2;\n    top: -1px;\n    left: 50%;\n\n    width: 2px;\n    height: 100%;\n\n    background-color: #fff;\n  }\n</style>\n","export default \"precision mediump float;\\n\\nuniform vec2 resolution;\\nuniform float yaw;\\nuniform float roll;\\nuniform float pitch;\\n\\nconst float pi = 3.1415927;\\nconst float deg = pi / 180.0;\\n\\n// Uncomment to see the lat-long grid for context\\n#define SHOW_LARGE_GRID\\n#define SHOW_SPHERE\\n#define SHOW_SPHERE_GRID\\n\\nmat3 rotationAll(float yaw, float pitch, float roll) {\\n        /// yaw\\n    return mat3(\\n\\n    cos(yaw), 0, -sin(yaw),\\n       0,     1,    0,\\n    sin(yaw), 0, cos(yaw))\\n/// pitch\\n     * mat3(\\n    1,     0,          0,\\n    0, cos(pitch), sin(pitch),\\n    0, -sin(pitch), cos(pitch))\\n\\n /// roll\\n     * mat3(\\n    cos(roll), sin(roll),  0,\\n    -sin(roll), cos(roll), 0,\\n    0,            0,       1);\\n}\\n\\nvoid main() {\\n    vec2 uv = gl_FragCoord.xy / resolution;\\n    float scale = 1.0 / resolution.x; // min(resolution.x, resolution.y);\\n    vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\\n\\n\\tconst float verticalFieldOfView = 50.0 * deg;\\n\\tconst float insetSphereRadius = 0.5;\\n\\n\\n    // Inset sphere\\n    vec2 spherePoint = (uv - insetSphereRadius) / insetSphereRadius; //(uv - insetSphereRadius) / insetSphereRadius;\\n    if (length(spherePoint) <= 1.0) {\\n        vec3 c = vec3(0);\\n        vec2 s = clamp(spherePoint, vec2(-1.0), vec2(1.0));\\n\\n        // Show convex sphere grid lines\\n        // vec3 dir = rotationAll(yaw, pitch,roll) * vec3(s.xy, sqrt(max(0.0, 1.0 - dot(s.xy, s.xy))));\\n        //             float latLongLine = (1.0 - pow(smoothstep(0.0, 0.09, min(abs(fract(atan(dir.y, length(dir.xz)) / (15.0 * deg)) - 0.5), abs(fract(atan(dir.x, dir.z) / (15.0 * deg)) - 0.5)) * 2.0), 10.0));\\n        //             c += latLongLine * vec3(-dir.y, dir.y, 1);\\n\\n        // show concave sphere grid lines:\\n        vec3 dir = rotationAll(yaw, pitch,roll) * normalize(vec3(s.xy, 1.0));\\n        // vec3 dir = rotationAll(yaw, pitch,roll) * vec3(s.xy, sqrt(max(0.0, 1.0 - dot(s.xy, s.xy))));\\n        // float latLongLine = (1.0 - pow(smoothstep(0.0, 0.09, min(abs(fract(atan(dir.y, length(dir.xz)) / (15.0 * deg)) - 0.5), abs(fract(atan(dir.x, dir.z) / (15.0 * deg)) - 0.5)) * 2.0), 10.0));\\n        // float latLongLine = (1.0 - pow(smoothstep(0.0, 0.04, min(abs(fract(atan(dir.y, length(dir.xz)) / (15.0 * deg)) - 0.5), abs(fract(atan(dir.x, dir.z) / (15.0 * deg)) - 0.5)) * 2.0), 10.0));\\n\\n\\n        float latLine = (1.0 - pow(smoothstep(0.0, 0.4,abs(fract(atan(dir.y, length(dir.xz)) / (15.0 * deg)) - 0.5) * 2.0), 1.0));\\n\\n        float longLine = (1.0 - pow(smoothstep(0.0, 0.4, abs(fract(atan(dir.x, dir.z) / (15.0 * deg)) - 0.5) * 2.0), 10.0));\\n\\n\\n        c += (max(latLine,longLine) * 0.8) * vec3(dir.y / 2.0,  dir.y / 2.0 + 0.5, dir.y / 2.0 + 1.0) *(dir.y / 2.0 + 0.7);\\n                // c += latLine * vec3(1.0 - abs(dir.y),  dir.y - 0.5, -dir.y + 0.5) *(dir.y / 2.0 + 0.5);\\n                // c += longLine *  vec3(dir.y / 2.0 + 0.5,  dir.y / 2.0 + 0.5, dir.y / 2.0 + 0.5) / 2.0;\\n\\n        // Fade the inset sphere to antialias its border transition\\n        float fade = clamp((1.0 - length(spherePoint)) * 2.0, 0.0, 1.0);\\n        color.rgb = mix(vec3(0), c, fade);\\n        float fade2 = clamp((1.0 - length(spherePoint)) * 5.0, 0.0, 0.4);\\n        color.a = fade2;\\n    }\\n\\n  gl_FragColor = color;\\n}\\n\"","<script lang=\"ts\">\n  import { rovHeading, rovPitch, rovRoll } from \"../js/sensors\";\n  import fragmentShader from \"../assets/shaders/AHRS_Sphere.glsl?raw\";\n  import * as twgl from \"twgl.js\";\n  import { onMount } from \"svelte\";\n  import { getColors } from \"../js/colorsVariety\";\n  import { log, logDebug, logInfo, logWarn, logError } from \"../js/shared/logging\";\n\n  let canvas: HTMLCanvasElement;\n  const varietyColor = getColors();\n  $: classes = `${$$props.class ?? \"\"}`;\n\n  // the most basic vertex shader possible:\n  const vertexShader = `\nattribute vec4 position;\nvoid main() {\n  gl_Position = position;\n}\n`;\n\n  let gl: any, programInfo: any, bufferInfo: any;\n  $: if (programInfo && gl) {\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n\n    // log(\"rovHeading: \", $rovHeading, \"rovPitch: \", $rovPitch, \"rovRoll: \", $rovRoll);\n\n    const uniforms = {\n      yaw: $rovHeading * (3.14 / 180) * -1,\n      pitch: $rovPitch * (3.14 / 180) * -1,\n      roll: $rovRoll * (3.14 / 180),\n      resolution: [gl.canvas.width, gl.canvas.height],\n    };\n\n    gl.useProgram(programInfo.program);\n    twgl.setBuffersAndAttributes(gl, programInfo, bufferInfo);\n    twgl.setUniforms(programInfo, uniforms);\n    twgl.drawBufferInfo(gl, bufferInfo);\n  }\n\n  onMount(() => {\n    gl = canvas.getContext(\"webgl\");\n    if (!gl) {\n      logWarn(\"Unable to initialize WebGL. Your browser or machine may not support it.\");\n      return;\n    }\n    programInfo = twgl.createProgramInfo(gl, [vertexShader, fragmentShader]);\n    bufferInfo = twgl.createBufferInfoFromArrays(gl, {\n      position: [-1, -1, 0, 1, -1, 0, -1, 1, 0, -1, 1, 0, 1, -1, 0, 1, 1, 0], // square out of two triangles\n    });\n  });\n</script>\n\n<div class={\"border-2 shadow-md rounded-md p-2 \" + varietyColor.bg + \" \" + varietyColor.border + \" \" + classes}>\n  <canvas id=\"AHRS-display\" width=\"100\" height=\"100\" class=\"w-full aspect-square\" bind:this={canvas} />\n</div>\n"],"names":["ctx","attr","div2","div2_class_value","null_to_empty","insert_hydration","target","anchor","append_hydration","div0","div1","dirty","fragmentShader","div","div_class_value","canvas_1","canvas","varietyColor","getColors","vertexShader","gl","programInfo","bufferInfo","onMount","logWarn","$$invalidate","twgl.createProgramInfo","twgl.createBufferInfoFromArrays","$$value","classes","$$props","uniforms","$rovHeading","$rovPitch","$rovRoll","twgl.setBuffersAndAttributes","twgl.setUniforms","twgl.drawBufferInfo"],"mappings":"+xBAcqEA,EAAW,CAAA,CAAA,KAAA,EAFpEC,EAAAC,EAAA,QAAAC,EAAAC,EAAA,uHAAyHJ,EAAQ,CAAA,EAAA,OAAS,EAAE,EAAA,iBAAA,wDAAxJK,EAGKC,EAAAJ,EAAAK,CAAA,EAFHC,EAAmBN,EAAAO,CAAA,SACnBD,EAAsFN,EAAAQ,CAAA,+CAAnBV,EAAW,CAAA,CAAA,KAAA,EAFpEW,EAAA,GAAAR,KAAAA,EAAAC,EAAA,uHAAyHJ,EAAQ,CAAA,EAAA,OAAS,EAAE,EAAA,4NCZxJ,MAAeY,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mTCoDHX,EAAAY,EAAA,QAAAC,EAAA,qCAAuCd,EAAa,CAAA,EAAA,GAAK,IAAMA,EAAa,CAAA,EAAA,OAAS,IAAMA,EAAO,CAAA,CAAA,UAA9GK,EAEKC,EAAAO,EAAAN,CAAA,EADHC,EAAoGK,EAAAE,CAAA,oBAD1FJ,EAAA,GAAAG,KAAAA,EAAA,qCAAuCd,EAAa,CAAA,EAAA,GAAK,IAAMA,EAAa,CAAA,EAAA,OAAS,IAAMA,EAAO,CAAA,6IA5CxG,IAAAgB,QACEC,EAAeC,IAIfC,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOF,IAAAC,EAASC,EAAkBC,EAmB/BC,EAAA,IAAA,CAEO,OADLH,EAAKJ,EAAO,WAAW,OAAO,CAAA,EACzB,CAAAI,EAAA,CACHI,EAAQ,yEAAyE,SAGnFC,EAAA,EAAAJ,EAAcK,EAAuBN,EAAK,CAAAD,EAAcP,CAAc,CAAA,CAAA,EACtEa,EAAA,EAAAH,EAAaK,EAAgCP,EAAA,CAC3C,SAAA,CAAA,MAAmB,EAAG,EAAG,GAAI,KAAO,EAAG,EAAG,GAAI,EAAG,EAAG,EAAA,GAAO,EAAG,EAAG,EAAG,CAAC,gDAMkBJ,EAAMY,2EA3C9FH,EAAA,EAAAI,EAAA,GAAaC,EAAQ,OAAS,EAAE,EAAA,kBAW5BT,GAAeD,EAAA,CACpBA,EAAG,SAAS,EAAG,EAAGA,EAAG,OAAO,MAAOA,EAAG,OAAO,MAAM,EAI7C,MAAAW,EAAA,CACJ,IAAKC,GAAe,KAAO,KAAO,GAClC,MAAOC,GAAa,KAAO,KAAO,GAClC,KAAMC,GAAY,KAAO,KACzB,WAAA,CAAad,EAAG,OAAO,MAAOA,EAAG,OAAO,MAAM,GAGhDA,EAAG,WAAWC,EAAY,OAAO,EACjCc,EAA6Bf,EAAIC,EAAaC,CAAU,EACxDc,EAAiBf,EAAaU,CAAQ,EACtCM,EAAoBjB,EAAIE,CAAU"}