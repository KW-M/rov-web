{"version":3,"file":"focusTrap.C1iSgani.js","sources":["../../../../../../../node_modules/.pnpm/@skeletonlabs+skeleton@2.10.2_svelte@4.2.19/node_modules/@skeletonlabs/skeleton/dist/actions/FocusTrap/focusTrap.js"],"sourcesContent":["// Action: Focus Trap\nexport function focusTrap(node, enabled) {\n    const elemWhitelist = 'a[href]:not([tabindex=\"-1\"]), button:not([tabindex=\"-1\"]), input:not([tabindex=\"-1\"]), textarea:not([tabindex=\"-1\"]), select:not([tabindex=\"-1\"]), details:not([tabindex=\"-1\"]), [tabindex]:not([tabindex=\"-1\"])';\n    let elemFirst;\n    let elemLast;\n    // When the first element is selected, shift+tab pressed, jump to the last selectable item.\n    function onFirstElemKeydown(e) {\n        if (e.shiftKey && e.code === 'Tab') {\n            e.preventDefault();\n            elemLast.focus();\n        }\n    }\n    // When the last item selected, tab pressed, jump to the first selectable item.\n    function onLastElemKeydown(e) {\n        if (!e.shiftKey && e.code === 'Tab') {\n            e.preventDefault();\n            elemFirst.focus();\n        }\n    }\n    // Sort focusable elements by tabindex, positive first, then 0\n    const sortByTabIndex = (focusableElems) => {\n        return focusableElems\n            .filter((elem) => elem.tabIndex >= 0)\n            .sort((a, b) => {\n            if (a.tabIndex === 0 && b.tabIndex > 0)\n                return 1; // Move 0 to end of array\n            else if (a.tabIndex > 0 && b.tabIndex === 0)\n                return -1; // Move 0 to end of array\n            else\n                return a.tabIndex - b.tabIndex; // Sort non-zero values in ascending order\n        });\n    };\n    // Get element with smallest focusindex value, or first focusable element\n    const getFocusTrapTarget = (elemFirst) => {\n        // Get elements with data-focusindex attribute\n        const focusindexElements = [...node.querySelectorAll('[data-focusindex]')];\n        if (!focusindexElements || focusindexElements.length === 0)\n            return elemFirst;\n        // return smallest focusindex element or elemFirst\n        return (focusindexElements.sort((a, b) => {\n            return +a.dataset.focusindex - +b.dataset.focusindex;\n        })[0] || elemFirst);\n    };\n    const onScanElements = (fromObserver) => {\n        if (enabled === false)\n            return;\n        // Gather all focusable elements, sorted according to tabindex\n        const focusableElems = sortByTabIndex(Array.from(node.querySelectorAll(elemWhitelist)));\n        if (focusableElems.length) {\n            // Set first/last focusable elements\n            elemFirst = focusableElems[0];\n            elemLast = focusableElems[focusableElems.length - 1];\n            // Auto-focus focusTrapTarget or first focusable element only when not called from observer\n            if (!fromObserver)\n                getFocusTrapTarget(elemFirst).focus();\n            // Listen for keydown on first & last element\n            elemFirst.addEventListener('keydown', onFirstElemKeydown);\n            elemLast.addEventListener('keydown', onLastElemKeydown);\n        }\n    };\n    onScanElements(false);\n    function onCleanUp() {\n        if (elemFirst)\n            elemFirst.removeEventListener('keydown', onFirstElemKeydown);\n        if (elemLast)\n            elemLast.removeEventListener('keydown', onLastElemKeydown);\n    }\n    // When children of node are changed (added or removed)\n    const onObservationChange = (mutationRecords, observer) => {\n        if (mutationRecords.length) {\n            onCleanUp();\n            onScanElements(true);\n        }\n        return observer;\n    };\n    const observer = new MutationObserver(onObservationChange);\n    observer.observe(node, { childList: true, subtree: true });\n    // Lifecycle\n    return {\n        update(newArgs) {\n            enabled = newArgs;\n            newArgs ? onScanElements(false) : onCleanUp();\n        },\n        destroy() {\n            onCleanUp();\n            observer.disconnect();\n        }\n    };\n}\n"],"names":["focusTrap","node","enabled","elemWhitelist","elemFirst","elemLast","onFirstElemKeydown","onLastElemKeydown","sortByTabIndex","focusableElems","elem","a","b","getFocusTrapTarget","focusindexElements","onScanElements","fromObserver","onCleanUp","onObservationChange","mutationRecords","observer","newArgs"],"mappings":"AACO,SAASA,EAAUC,EAAMC,EAAS,CACrC,MAAMC,EAAgB,mNACtB,IAAIC,EACAC,EAEJ,SAASC,EAAmB,EAAG,CACvB,EAAE,UAAY,EAAE,OAAS,QACzB,EAAE,eAAc,EAChBD,EAAS,MAAK,EAErB,CAED,SAASE,EAAkB,EAAG,CACtB,CAAC,EAAE,UAAY,EAAE,OAAS,QAC1B,EAAE,eAAc,EAChBH,EAAU,MAAK,EAEtB,CAED,MAAMI,EAAkBC,GACbA,EACF,OAAQC,GAASA,EAAK,UAAY,CAAC,EACnC,KAAK,CAACC,EAAGC,IACND,EAAE,WAAa,GAAKC,EAAE,SAAW,EAC1B,EACFD,EAAE,SAAW,GAAKC,EAAE,WAAa,EAC/B,GAEAD,EAAE,SAAWC,EAAE,QAC7B,EAGCC,EAAsBT,GAAc,CAEtC,MAAMU,EAAqB,CAAC,GAAGb,EAAK,iBAAiB,mBAAmB,CAAC,EACzE,MAAI,CAACa,GAAsBA,EAAmB,SAAW,EAC9CV,EAEHU,EAAmB,KAAK,CAACH,EAAGC,IACzB,CAACD,EAAE,QAAQ,WAAa,CAACC,EAAE,QAAQ,UAC7C,EAAE,CAAC,GAAKR,CACjB,EACUW,EAAkBC,GAAiB,CACrC,GAAId,IAAY,GACZ,OAEJ,MAAMO,EAAiBD,EAAe,MAAM,KAAKP,EAAK,iBAAiBE,CAAa,CAAC,CAAC,EAClFM,EAAe,SAEfL,EAAYK,EAAe,CAAC,EAC5BJ,EAAWI,EAAeA,EAAe,OAAS,CAAC,EAE9CO,GACDH,EAAmBT,CAAS,EAAE,QAElCA,EAAU,iBAAiB,UAAWE,CAAkB,EACxDD,EAAS,iBAAiB,UAAWE,CAAiB,EAElE,EACIQ,EAAe,EAAK,EACpB,SAASE,GAAY,CACbb,GACAA,EAAU,oBAAoB,UAAWE,CAAkB,EAC3DD,GACAA,EAAS,oBAAoB,UAAWE,CAAiB,CAChE,CAED,MAAMW,EAAsB,CAACC,EAAiBC,KACtCD,EAAgB,SAChBF,IACAF,EAAe,EAAI,GAEhBK,GAELA,EAAW,IAAI,iBAAiBF,CAAmB,EACzD,OAAAE,EAAS,QAAQnB,EAAM,CAAE,UAAW,GAAM,QAAS,EAAI,CAAE,EAElD,CACH,OAAOoB,EAAS,CACZnB,EAAUmB,EACVA,EAAUN,EAAe,EAAK,EAAIE,EAAS,CAC9C,EACD,SAAU,CACNA,IACAG,EAAS,WAAU,CACtB,CACT,CACA","x_google_ignoreList":[0]}